"use server";

import { payload } from "@/lib/payload";
import { model, ANALYSIS_PROMPT, createStructuredModel } from "@/lib/genAI";

// Helper to clean AI JSON response
function cleanAIResponse(text) {
  // Remove potential markdown fences and trim whitespace
  return text.replace(/^```json\s*|\s*```$/g, '').trim();
}

// Updated Prompt for AI dynamic categorization and insights (includes Title)
const REPORT_INSIGHTS_PROMPT = `Analyze the following report titles and descriptions:
---
{reports_data}
---
Based *only* on the titles and descriptions provided:
1. Identify the main event or issue described in each report.
2. Group similar reports together and create specific, descriptive category names for these groups (e.g., "Traffic Accident - Minor Injury", "Flood Damage - Residential", "Noise Complaint - Late Night", "Stray Animal Report", "Domestic Dispute"). Do NOT use generic categories like "Incident", "Accident", "Disaster", "Other" unless no specific theme can be identified for a group.
3. Count the number of reports in each category you created.
4. Provide 3-5 key insights derived *directly* from the content and the generated categories (e.g., "Frequent noise complaints reported from Zone 3", "Increase in stray dog reports during summer").
5. Provide 3-5 actionable recommendations for the barangay based *specifically* on the identified report types and insights (e.g., "Deploy additional patrols to Zone 3 during evening hours", "Initiate a stray animal control program").

Return ONLY a JSON object in this exact format:

{
  "byType": [{"type": "Generated Category Name 1", "count": number}, {"type": "Generated Category Name 2", "count": number}, ...],
  "insights": ["Insight 1", "Insight 2", "Insight 3", ...],
  "recommendations": ["Recommendation 1", "Recommendation 2", "Recommendation 3", ...]
}

Ensure counts reflect *only* the provided reports. Insights and recommendations must be relevant to a local barangay government.
`;

// Updated Schema (remains the same, but applied to the new prompt)
const reportInsightsSchema = {
  type: "object",
  properties: {
    byType: {
      type: "array",
      description: "Array of report categories dynamically identified by the AI based on titles and descriptions, along with their counts.",
      items: {
        type: "object",
        properties: {
          type: { type: "string", description: "The category name generated by the AI (e.g., 'Traffic Accident', 'Noise Complaint', 'Flood Damage')." },
          count: { type: "number", description: "Number of reports matching this category." }
        },
        required: ["type", "count"]
      }
    },
    insights: { type: "array", items: { type: "string" }, description: "Key insights derived from the report content and categories." },
    recommendations: { type: "array", items: { type: "string" }, description: "Actionable recommendations based on the insights." }
  },
  required: ["byType", "insights", "recommendations"]
};

// Model for structured report insights (using the updated schema)
const insightsModel = createStructuredModel(reportInsightsSchema);

// Fetch and process reports data for dashboard
export async function calculateReportsDashboardData(params = {}) {
  const { year = "", month = "", status = "all" } = params;

  const where = {};
  if (status && status !== "all") where.reportStatus = { equals: status };
  
  let dateFilter = {};
  if (year) {
    if (month) {
      const startDate = new Date(Date.UTC(Number(year), Number(month) - 1, 1));
      const endDate = new Date(Date.UTC(Number(year), Number(month), 0, 23, 59, 59, 999));
      dateFilter = { 
        greater_than_equal: startDate.toISOString(),
        less_than_equal: endDate.toISOString()
      };
    } else {
      const startDate = `${year}-01-01T00:00:00.000Z`;
      const endDate = `${year}-12-31T23:59:59.999Z`;
      dateFilter = { 
        greater_than_equal: startDate,
        less_than_equal: endDate
      };
    }
    where.date = dateFilter; 
  }
  
  const { docs } = await payload.find({
    collection: "reports",
    where,
    limit: 1000, 
    sort: "-date"
  });

  const total = docs.length;
  const open = docs.filter(r => r.reportStatus === "open").length;
  const inProgress = docs.filter(r => r.reportStatus === "inProgress").length;
  const closed = docs.filter(r => r.reportStatus === "closed").length;

  const byStatus = [
    { status: "Open", count: open },
    { status: "In Progress", count: inProgress },
    { status: "Closed", count: closed },
  ];

  let trends = [];
  let trendType = 'none';
  if (year && !month) {
    trendType = 'monthly';
    const monthlyTrendsMap = {};
    docs.forEach(r => {
       if (r.date) {
          const m = new Date(r.date).toISOString().slice(5, 7);
          monthlyTrendsMap[m] = (monthlyTrendsMap[m] || 0) + 1;
        }
    });
    trends = Object.entries(monthlyTrendsMap)
      .map(([month, count]) => ({ month: month, count }))
      .sort((a, b) => a.month.localeCompare(b.month));
  } else if (!year) {
    trendType = 'yearly';
    const allDocs = await payload.find({ collection: 'reports', limit: 2000, sort: '-date' });
    const yearlyTrendsMap = {};
    allDocs.docs.forEach(r => {
       if (r.date) {
          const y = new Date(r.date).getFullYear();
          yearlyTrendsMap[y] = (yearlyTrendsMap[y] || 0) + 1;
        }
    });
    trends = Object.entries(yearlyTrendsMap)
      .map(([year, count]) => ({ year: Number(year), count }))
      .sort((a, b) => a.year - b.year);
  }

  return {
    overview: { total, open, inProgress, closed },
    byStatus,
    trends: trends, 
    trendType: trendType
  };
}

// AI: Analyze report trends (monthly or yearly)
export async function analyzeReportTrendsAI(params = {}) {
  const { trends = [], type = 'yearly' } = params;
  if (!trends || trends.length === 0 || type === 'none') { // Add type === 'none' check
    return { trend: "stable", percentageChange: "0%", analysis: "Not enough data or specific month selected for trend analysis.", prediction: "No prediction available.", insights: [], recommendations: [] };
  }
  const data = type === 'monthly' 
    ? trends.map(m => `Month ${m.month}: ${m.count}`).join("\n")
    : trends.map(y => `${y.year}: ${y.count}`).join("\n");
    
  const prompt = ANALYSIS_PROMPT.replace("{data}", data).replace("time-series data", `${type} time-series data`);
  
  try {
    const result = await model.generateContent(prompt);
    const cleanedText = cleanAIResponse(result.response.text()); // Clean the response
    return JSON.parse(cleanedText);
  } catch (e) {
    console.error(`Error analyzing report ${type} trends:`, e);
    return { trend: "stable", percentageChange: "0%", analysis: "AI analysis failed.", prediction: "No prediction.", insights: [], recommendations: [] };
  }
} 

// AI: Categorize reports dynamically and provide insights/recommendations
export async function analyzeReportInsightsAI(params = {}) {
  const { year = "", month = "", status = "all" } = params; 

  const where = {};
  if (status && status !== "all") where.reportStatus = { equals: status };
  
  let dateFilter = {};
  if (year) {
    if (month) {
      const startDate = new Date(Date.UTC(Number(year), Number(month) - 1, 1));
      const endDate = new Date(Date.UTC(Number(year), Number(month), 0, 23, 59, 59, 999));
      dateFilter = { 
        greater_than_equal: startDate.toISOString(),
        less_than_equal: endDate.toISOString()
      };
    } else {
      const startDate = `${year}-01-01T00:00:00.000Z`;
      const endDate = `${year}-12-31T23:59:59.999Z`;
      dateFilter = { 
        greater_than_equal: startDate,
        less_than_equal: endDate
      };
    }
    where.date = dateFilter; 
  }

  // Fetch documents including title and description
  const { docs } = await payload.find({
    collection: "reports",
    where,
    limit: 150, 
    sort: "-date",
    select: ["title", "description"] // Fetch title and description
  });

  if (!docs || docs.length === 0) {
    return { byType: [], insights: ["No reports found for analysis with the current filters."], recommendations: [] };
  }

  // Prepare data for the prompt (including title)
  const reports_data = docs.map((doc, index) => 
    `Report ${index + 1}:\nTitle: ${doc.title || "(No title)"}\nDescription: ${doc.description || "(No description)"}`
  ).join("\n---\n");
  const prompt = REPORT_INSIGHTS_PROMPT.replace("{reports_data}", reports_data);

  try {
    console.log("Sending prompt to insightsModel..."); 
    const result = await insightsModel.generateContent(prompt);
    const cleanedText = cleanAIResponse(result.response.text()); // Clean the response
    console.log("Received AI insights response:", cleanedText); 
    return JSON.parse(cleanedText); 
  } catch (e) {
    console.error("Error analyzing report insights:", e);
    return { 
      byType: [], 
      insights: ["AI categorization failed. Please check logs."], 
      recommendations: [] 
    };
  }
} 