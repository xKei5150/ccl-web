"use server";

import { payload } from "@/lib/payload";
import { model, ANALYSIS_PROMPT, createStructuredModel } from "@/lib/genAI";

// Helper to clean AI JSON response
function cleanAIResponse(text) {
  // Remove potential markdown fences and trim whitespace
  return text.replace(/^```json\s*|\s*```$/g, '').trim();
}

// Updated Prompt for AI dynamic categorization and insights (includes Title)
const REPORT_INSIGHTS_PROMPT = `Analyze the following report titles and descriptions:
---
{reports_data}
---
Based *only* on the titles and descriptions provided:
1. Identify the main event or issue described in each report.
2. Group similar reports together and create specific, descriptive category names for these groups (e.g., "Traffic Accident - Minor Injury", "Flood Damage - Residential", "Noise Complaint - Late Night", "Stray Animal Report", "Domestic Dispute"). Do NOT use generic categories like "Incident", "Accident", "Disaster", "Other" unless no specific theme can be identified for a group.
3. Count the number of reports in each category you created.
4. Provide 3-5 key insights derived *directly* from the content and the generated categories (e.g., "Frequent noise complaints reported from Zone 3", "Increase in stray dog reports during summer").
5. Provide 3-5 actionable recommendations for the barangay based *specifically* on the identified report types and insights (e.g., "Deploy additional patrols to Zone 3 during evening hours", "Initiate a stray animal control program").

Return ONLY a JSON object in this exact format:

{
  "byType": [{"type": "Generated Category Name 1", "count": number}, {"type": "Generated Category Name 2", "count": number}, ...],
  "insights": ["Insight 1", "Insight 2", "Insight 3", ...],
  "recommendations": ["Recommendation 1", "Recommendation 2", "Recommendation 3", ...]
}

Ensure counts reflect *only* the provided reports. Insights and recommendations must be relevant to a local barangay government.
`;

// Updated Schema (remains the same, but applied to the new prompt)
const reportInsightsSchema = {
  type: "object",
  properties: {
    byType: {
      type: "array",
      description: "Array of report categories dynamically identified by the AI based on titles and descriptions, along with their counts.",
      items: {
        type: "object",
        properties: {
          type: { type: "string", description: "The category name generated by the AI (e.g., 'Traffic Accident', 'Noise Complaint', 'Flood Damage')." },
          count: { type: "number", description: "Number of reports matching this category." }
        },
        required: ["type", "count"]
      }
    },
    insights: { type: "array", items: { type: "string" }, description: "Key insights derived from the report content and categories." },
    recommendations: { type: "array", items: { type: "string" }, description: "Actionable recommendations based on the insights." }
  },
  required: ["byType", "insights", "recommendations"]
};

// Model for structured report insights (using the updated schema)
const insightsModel = createStructuredModel(reportInsightsSchema);

// Fetch and process reports data for dashboard
export async function calculateReportsDashboardData(params = {}) {
  const { year = "", month = "", status = "all" } = params;

  const where = {};
  if (status && status !== "all") where.reportStatus = { equals: status };
  
  let dateFilter = {};
  if (year) {
    if (month) {
      const startDate = new Date(Date.UTC(Number(year), Number(month) - 1, 1));
      const endDate = new Date(Date.UTC(Number(year), Number(month), 0, 23, 59, 59, 999));
      dateFilter = { 
        greater_than_equal: startDate.toISOString(),
        less_than_equal: endDate.toISOString()
      };
    } else {
      const startDate = `${year}-01-01T00:00:00.000Z`;
      const endDate = `${year}-12-31T23:59:59.999Z`;
      dateFilter = { 
        greater_than_equal: startDate,
        less_than_equal: endDate
      };
    }
    where.date = dateFilter; 
  }
  
  const { docs } = await payload.find({
    collection: "reports",
    where,
    limit: 1000, 
    sort: "-date"
  });

  const total = docs.length;
  const open = docs.filter(r => r.reportStatus === "open").length;
  const inProgress = docs.filter(r => r.reportStatus === "inProgress").length;
  const closed = docs.filter(r => r.reportStatus === "closed").length;

  const byStatus = [
    { status: "Open", count: open },
    { status: "In Progress", count: inProgress },
    { status: "Closed", count: closed },
  ];

  let trends = [];
  let trendType = 'none';
  if (year && !month) {
    trendType = 'monthly';
    const monthlyTrendsMap = {};
    docs.forEach(r => {
       if (r.date) {
          const m = new Date(r.date).toISOString().slice(5, 7);
          monthlyTrendsMap[m] = (monthlyTrendsMap[m] || 0) + 1;
        }
    });
    trends = Object.entries(monthlyTrendsMap)
      .map(([month, count]) => ({ month: month, count }))
      .sort((a, b) => a.month.localeCompare(b.month));
  } else if (!year) {
    trendType = 'yearly';
    const allDocs = await payload.find({ collection: 'reports', limit: 2000, sort: '-date' });
    const yearlyTrendsMap = {};
    allDocs.docs.forEach(r => {
       if (r.date) {
          const y = new Date(r.date).getFullYear();
          yearlyTrendsMap[y] = (yearlyTrendsMap[y] || 0) + 1;
        }
    });
    trends = Object.entries(yearlyTrendsMap)
      .map(([year, count]) => ({ year: Number(year), count }))
      .sort((a, b) => a.year - b.year);
  }

  return {
    overview: { total, open, inProgress, closed },
    byStatus,
    trends: trends, 
    trendType: trendType
  };
}

// AI: Analyze report trends (monthly or yearly)
export async function analyzeReportTrendsAI(params = {}) {
  const { trends = [], type = 'yearly' } = params;
  if (!trends || trends.length === 0 || type === 'none') { // Add type === 'none' check
    return { trend: "stable", percentageChange: "0%", analysis: "Not enough data or specific month selected for trend analysis.", prediction: "No prediction available.", insights: [], recommendations: [] };
  }
  const data = type === 'monthly' 
    ? trends.map(m => `Month ${m.month}: ${m.count}`).join("\n")
    : trends.map(y => `${y.year}: ${y.count}`).join("\n");
    
  const prompt = ANALYSIS_PROMPT.replace("{data}", data).replace("time-series data", `${type} time-series data`);
  
  try {
    const result = await model.generateContent(prompt);
    const cleanedText = cleanAIResponse(result.response.text()); // Clean the response
    return JSON.parse(cleanedText);
  } catch (e) {
    console.error(`Error analyzing report ${type} trends:`, e);
    return { trend: "stable", percentageChange: "0%", analysis: "AI analysis failed.", prediction: "No prediction.", insights: [], recommendations: [] };
  }
} 

// AI: Categorize reports dynamically and provide insights/recommendations
export async function analyzeReportInsightsAI(params = {}) {
  const { year = "", month = "", status = "all" } = params; 

  const where = {};
  if (status && status !== "all") where.reportStatus = { equals: status };
  
  let dateFilter = {};
  if (year) {
    if (month) {
      const startDate = new Date(Date.UTC(Number(year), Number(month) - 1, 1));
      const endDate = new Date(Date.UTC(Number(year), Number(month), 0, 23, 59, 59, 999));
      dateFilter = { 
        greater_than_equal: startDate.toISOString(),
        less_than_equal: endDate.toISOString()
      };
    } else {
      const startDate = `${year}-01-01T00:00:00.000Z`;
      const endDate = `${year}-12-31T23:59:59.999Z`;
      dateFilter = { 
        greater_than_equal: startDate,
        less_than_equal: endDate
      };
    }
    where.date = dateFilter; 
  }

  // Fetch documents including title and description
  const { docs } = await payload.find({
    collection: "reports",
    where,
    limit: 150, 
    sort: "-date",
    select: ["title", "description"] // Fetch title and description
  });

  if (!docs || docs.length === 0) {
    return { byType: [], insights: ["No reports found for analysis with the current filters."], recommendations: [] };
  }

  // Prepare data for the prompt (including title)
  const reports_data = docs.map((doc, index) => 
    `Report ${index + 1}:\nTitle: ${doc.title || "(No title)"}\nDescription: ${doc.description || "(No description)"}`
  ).join("\n---\n");
  const prompt = REPORT_INSIGHTS_PROMPT.replace("{reports_data}", reports_data);

  try {
    console.log("Sending prompt to insightsModel..."); 
    const result = await insightsModel.generateContent(prompt);
    const cleanedText = cleanAIResponse(result.response.text()); // Clean the response
    console.log("Received AI insights response:", cleanedText); 
    return JSON.parse(cleanedText); 
  } catch (e) {
    console.error("Error analyzing report insights:", e);
    return { 
      byType: [], 
      insights: ["AI categorization failed. Please check logs."], 
      recommendations: [] 
    };
  }
} 

// Export reports data to CSV
export async function exportReportsData(params = {}) {
  try {
    const { reportType = "overview", year = "", month = "", status = "all" } = params;
    let csvContent = "";
    let filename = `reports-${reportType}-${year || "all"}-${month || "all"}.csv`;
    
    if (reportType === "overview") {
      // First get the dashboard data
      const dashboardData = await calculateReportsDashboardData({ year, month, status });
      
      if (!dashboardData || !dashboardData.overview) {
        return { error: "No report data available to export" };
      }
      
      // Create overview CSV
      csvContent = "REPORTS OVERVIEW\n";
      csvContent += "Status,Count\n";
      csvContent += `Total,${dashboardData.overview.total || 0}\n`;
      csvContent += `Open,${dashboardData.overview.open || 0}\n`;
      csvContent += `In Progress,${dashboardData.overview.inProgress || 0}\n`;
      csvContent += `Closed,${dashboardData.overview.closed || 0}\n\n`;
      
      // Add status breakdown
      if (dashboardData.byStatus && dashboardData.byStatus.length > 0) {
        csvContent += "STATUS BREAKDOWN\n";
        csvContent += "Status,Count\n";
        dashboardData.byStatus.forEach(item => {
          csvContent += `${item.status},${item.count}\n`;
        });
        csvContent += "\n";
      }
      
      // Add trends data
      if (dashboardData.trends && dashboardData.trends.length > 0) {
        csvContent += "TRENDS\n";
        if (dashboardData.trendType === 'yearly') {
          csvContent += "Year,Count\n";
          dashboardData.trends.forEach(item => {
            csvContent += `${item.year},${item.count}\n`;
          });
        } else if (dashboardData.trendType === 'monthly') {
          csvContent += "Month,Count\n";
          dashboardData.trends.forEach(item => {
            csvContent += `${item.month},${item.count}\n`;
          });
        }
      }
    } else if (reportType === "insights") {
      // Get the insights data
      const insightsData = await analyzeReportInsightsAI({ year, month, status });
      
      if (!insightsData || (!insightsData.byType && !insightsData.insights)) {
        return { error: "No insights data available to export" };
      }
      
      // Report types breakdown
      if (insightsData.byType && insightsData.byType.length > 0) {
        csvContent = "REPORT CATEGORIES\n";
        csvContent += "Category,Count\n";
        insightsData.byType.forEach(item => {
          csvContent += `${escapeCsvValue(item.type)},${item.count}\n`;
        });
        csvContent += "\n";
      }
      
      // Insights
      if (insightsData.insights && insightsData.insights.length > 0) {
        csvContent += "KEY INSIGHTS\n";
        insightsData.insights.forEach((insight, index) => {
          csvContent += `${index + 1},${escapeCsvValue(insight)}\n`;
        });
        csvContent += "\n";
      }
      
      // Recommendations
      if (insightsData.recommendations && insightsData.recommendations.length > 0) {
        csvContent += "RECOMMENDATIONS\n";
        insightsData.recommendations.forEach((recommendation, index) => {
          csvContent += `${index + 1},${escapeCsvValue(recommendation)}\n`;
        });
      }
    } else if (reportType === "trends") {
      // Get the trends analysis
      const trendsData = await analyzeReportTrendsAI({
        trends: (await calculateReportsDashboardData({ year, month, status })).trends,
        type: month ? 'none' : year ? 'monthly' : 'yearly'
      });
      
      if (!trendsData) {
        return { error: "No trends data available to export" };
      }
      
      // Create trends CSV
      csvContent = "REPORTS TRENDS ANALYSIS\n\n";
      csvContent += `Trend,${trendsData.trend || "stable"}\n`;
      csvContent += `Percentage Change,${trendsData.percentageChange || "0%"}\n\n`;
      
      csvContent += "ANALYSIS\n";
      csvContent += `${escapeCsvValue(trendsData.analysis || "No analysis available.")}\n\n`;
      
      csvContent += "PREDICTION\n";
      csvContent += `${escapeCsvValue(trendsData.prediction || "No prediction available.")}\n\n`;
      
      // Insights
      if (trendsData.insights && trendsData.insights.length > 0) {
        csvContent += "KEY INSIGHTS\n";
        trendsData.insights.forEach((insight, index) => {
          csvContent += `${index + 1},${escapeCsvValue(insight)}\n`;
        });
        csvContent += "\n";
      }
      
      // Recommendations
      if (trendsData.recommendations && trendsData.recommendations.length > 0) {
        csvContent += "RECOMMENDATIONS\n";
        trendsData.recommendations.forEach((recommendation, index) => {
          csvContent += `${index + 1},${escapeCsvValue(recommendation)}\n`;
        });
      }
    }
    
    return {
      success: true,
      data: csvContent,
      filename,
      contentType: 'text/csv'
    };
  } catch (error) {
    console.error("Failed to export reports data:", error);
    return { error: "Failed to export reports data" };
  }
}

// Helper function to escape CSV values
function escapeCsvValue(value) {
  if (value === null || value === undefined) return '';
  
  const stringValue = String(value);
  // If the value contains commas, quotes, or newlines, wrap it in quotes and escape any existing quotes
  if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
    return `"${stringValue.replace(/"/g, '""')}"`;
  }
  
  return stringValue;
} 